#!/usr/bin/ruby
require 'rubygems'
require 'optparse'
require 'date'
require 'zlib'
require 'archive/tar/minitar'
include Archive::Tar

module Prune
  VERSION = [1,0,0]
  
  class CommandLineInterface
    def self.parse_and_run
      options = { :verbose => false, :did_work => false, :dry_run => false, :prompt => true, :archive => true }
      parser = OptionParser.new do |opts|
          opts.banner = "Usage: prune [options] folder"
          opts.on( "-v", "--verbose", "Prints much more frequently during execution about what it's doing." ) { options[:verbose] = true }
          opts.on( "-d", "--dry-run", "Categorizes files, but does not take any actions on them." ) { options[:dry_run] = true }
          opts.on( "-f", "--force", "--no-prompt", "Will take action without asking permissions; useful for automation." ) { options[:prompt] = false }
          opts.on( "-a", "--archive-folder", "The folder in which archives should be stored; defaults to <folder>/../<folder-name>-archives." ) { |path| options[:archive_path] = path }
          opts.on( "--no-archive", "Don't perform archival; typically if the files you're pruning are already compressed." ) { options[:archive] = false }
          opts.on_tail( "--version", "Displays version information." ) do 
            options[:did_work] = true
            puts "Prune #{VERSION.join('.')}, by Geoffrey Wiseman."
          end
          opts.on_tail( "-?", "--help", "Shows quick help about using prune." ) do
            options[:did_work] = true
            puts opts
          end
      end

      begin
        parser.parse!
      rescue OptionParser::ParseError
        $stderr.print "Error: " + $! + "\n"
        exit
      end
      
      if ARGV.size != 1 then
        print parser.help unless options[:did_work]
      else
        Pruner.new( options ).prune( ARGV.first )
      end
    end
  end
  
  class Pruner
    
    def initialize( options )
      @options = options
      @categories = Hash.new { |h,k| h[k] = [] } # initialize new keys with an empty array
      @analyzed_count = 0
    end
    
    def prune( folder_name )
      return puts( "ERROR: Cannot find folder: #{folder_name}" ) unless File.exists? folder_name
      return puts( "ERROR: #{folder_name} is not a folder" ) unless File.directory? folder_name
      policy = RetentionPolicy.new folder_name
      analyze folder_name, policy
      execute_prune( folder_name, policy ) unless @options[:dry_run]
    end
    
    def analyze( folder_name, policy )
      puts "Analyzing '#{folder_name}':"
      Dir.foreach folder_name do |file|
        analyze_file( policy, file )
      end
      print "\n" if @options[:verbose]
      
      display_categories policy
      print "\t#{@analyzed_count} file(s) analyzed\n"
    end
    
    def execute_prune( folder_name, policy )
      actions = 0
      if @options[:prompt] && !prompt then
        puts "Not proceeding; no actions taken."
      else
        @categories.each_pair do |category,files|
          action = policy.action( category )
          result = act( action, folder_name, files)
          if !result.nil? then
            puts result
            actions += 1
          end
        end
        puts "No actions necessary." if actions == 0
      end
    end
    
    def prompt
      print "Proceed? [y/N]: "
      response = STDIN.gets.chomp.strip.downcase
      return ['y','yes','true'].include? response
    end
    
    def act( action, folder_name, files )
      case action
      when :remove
        paths = files.map { |file| File.join folder_name, file }
        File.delete *paths
        "#{files.size} file(s) deleted"
      when :archive
        if @options[:archive] then
          archiver = Archiver.new( @options[:archive_path], folder_name, @options[:verbose] )
          if archiver.ready? then
            groups = group_by_month folder_name, files
            groups.each_pair do |month,files|
              archiver.archive( month, files )
            end
            sizes = groups.values.map { |x| x.size }.join( ', ' )
            "#{groups.size} archive(s) created (#{sizes} file(s), respectively)"
          else
            puts "Archive folder #{archiver.destination} does not exist and cannot be created."
          end
        end
      end
    end
    
    def group_by_month( folder_name, files )
      groups = Hash.new { |h,k| h[k] = [] }
      files.each do |file|
        month = File.mtime( File.join( folder_name, file ) ).month
        groups[ month ] << file
      end
      return groups
    end
    
    def display_categories( policy )
      @categories.each_pair do |category,files|
        print "\t#{policy.describe category} (#{policy.action category}):\n\t\t"
        puts files.join( "\n\t\t")
      end
    end
    
    def analyze_file( policy, file )
      category = policy.categorize( file )
      @categories[ category ] << file unless category.nil?
      @analyzed_count += 1
      print "\t#{file} -> #{category}\n" if @options[:verbose]
    end
  end

  class RetentionPolicy
  
    def initialize( folder_name )
      @folder_name = folder_name
      @today = Date.today
    end
  
    def categorize( file_name )
      path = File.join( @folder_name, file_name )
      created = Date.parse(File.mtime(path).strftime('%Y/%m/%d'))
      if File.directory? path then
        :dir
      elsif @today - created < 14 then
        :recent
      elsif @today.year == created.year && ( @today.month - created.month ) <= 1 then
        # this month, last month
        created.wday == 5 ? :sparse : :remove
      else 
        # earlier month
        created.wday == 5 ? :old : :remove
      end
    end
    
    def describe( category )
      case category
      when :dir
        "Directories"
      when :recent
        "Less Than 2 Weeks Old"
      when :sparse
        "Friday Older than Two Weeks"
      when :remove
        "Non-Friday Older than Two Weeks"
      when :old
        "Older than Two Months"
      end
    end
    
    def action( category )
      case category
      when :dir
        :ignore
      when :recent
        :retain
      when :sparse
        :retain
      when :remove
        :remove
      when :old
        :archive
      end
      
    end
  
  end
  
  class Archiver
    attr_reader :destination
    
    def initialize( destination, source, verbose )
      @source = source
      @verbose = verbose
      @destination = destination || get_default_dir      
    end
    
    def get_default_dir
      absolute = File.expand_path @source
      path = File.dirname absolute
      name = File.basename absolute
      File.join( path, "${name}-archives" )
    end
    
    def ready?
      begin
        Dir.mkdir @destination unless File.exists? @destination
        return true
      rescue SystemCallError
        return false
      end
    end
    
    def archive( month, files )
      month_name = Date::ABBR_MONTHNAMES[month]
      archive_path = File.join( @destination, "archive-#{month_name}.tar.gz")
      tgz = Zlib::GzipWriter.new( File.open( archive_path, 'wb' ) )
      paths = files.map { |file| File.join( @source, file ) }
      
      Minitar.pack( paths, tgz )
      puts "Compressed #{files.size} file(s) into #{archive_path} archive." if @verbose
      
      File.delete( *paths )
      puts "Removing #{files.size} compressed file(s)."
    end
  end
end

Prune::CommandLineInterface.parse_and_run
