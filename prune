#!/usr/bin/ruby
require 'optparse'
require 'date'

module Prune
  VERSION = [1,0,0]
  
  class CommandLineInterface
    def self.parse_and_run
      options = { :verbose => false, :did_work => false, :dry_run => false, :prompt => true }
      parser = OptionParser.new do |opts|
          opts.banner = "Usage: prune [options] folder"
          opts.on( "-v", "--verbose", "Prints much more frequently during execution about what it's doing." ) { options[:verbose] = true }
          opts.on_tail( "--version", "Displays version information." ) do 
            options[:did_work] = true
            puts "Prune #{VERSION.join('.')}, by Geoffrey Wiseman."
          end
          opts.on_tail( "-?", "--help", "Shows quick help about using prune." ) do
            options[:did_work] = true
            puts opts
          end
      end

      begin
        parser.parse!
      rescue OptionParser::ParseError
        $stderr.print "Error: " + $! + "\n"
        exit
      end
      
      if ARGV.size != 1 then
        print parser.help unless options[:did_work]
      else
        Pruner.new( options ).prune( ARGV.first )
      end
    end
  end
  
  class Pruner
    
    def initialize( options )
      @options = options
      @categories = Hash.new { |h,k| h[k] = [] } # initialize new keys with an empty array
      @analyzed_count = 0
    end
    
    def prune( folder_name )
      return puts "ERROR: Cannot find folder: #{folder_name}" unless File.exists? folder_name
      return puts "ERROR: #{folder_name} is not a folder" unless File.directory? folder_name
      puts "Analyzing '#{folder_name}':"
    
      policy = RetentionPolicy.new folder_name
      Dir.foreach folder_name do |file|
        analyze( policy, file )
      end
      print "\n" if @options[:verbose]
    
      display_categories( policy )
    
      print "\t#{@analyzed_count} file(s) analyzed\n"
    end
    
    def display_categories( policy )
      @categories.each_pair do |key,files|
        print "\t#{policy.describe key}:\n\t\t"
        puts files.join( "\n\t\t")
      end
    end
    
    def analyze( policy, file )
      category = policy.categorize( file )
      @categories[ category ] << file unless category.nil?
      @analyzed_count += 1
      print "\t#{file} -> #{category}\n" if @options[:verbose]
    end
  end

  class RetentionPolicy
  
    def initialize( folder_name )
      @folder_name = folder_name
      @today = Date.today
    end
  
    def categorize( file_name )
      path = File.join( @folder_name, file_name )
      created = Date.parse(File.ctime(path).strftime('%Y/%m/%d'))
      if File.directory? path then
        :dir
      elsif @today - created < 14 then
        :recent_retain
      elsif @today.year == created.year && ( @today.month - created.month ) == 0 then
        # this month, last month
        created.wday == 5 ? :sparse_retain : :remove
      else 
        # earlier month
        created.wday == 5 ? :old_archive : :remove
      end
    end
    
    def describe( category )
      case category
      when :dir
        "Directories (ignored)"
      when :recent_retain
        "Less Than 2 Weeks Old (retain)"
      when :sparse_retain
        "Friday Older than Two Weeks (retain)"
      when :remove
        "Non-Friday Older than Two Weeks (remove)"
      when :old_archive
        "Older than Two Months (archive)"
      end
    end
  
  end
end

Prune::CommandLineInterface.parse_and_run
